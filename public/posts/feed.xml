<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="http://localhost:1313/xml/base.min.xml" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Networking &amp; DevOps</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on Networking &amp; DevOps</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Aug 2025 14:05:54 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker Introduction</title>
      <link>http://localhost:1313/posts/docker/</link>
      <pubDate>Wed, 13 Aug 2025 14:05:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/docker/</guid>
      <description>&lt;p&gt;In the last few weeks I&amp;rsquo;ve been learning and playing with Docker.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;introduction&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#introduction&#34;&gt;Introduction&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Docker is an open-source platform that enables you to build, ship and run applications in containers. A container is a lightweight and portable self-sufficient unit that includes:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The application code&lt;/li&gt;&#xA;&lt;li&gt;Runtime&lt;/li&gt;&#xA;&lt;li&gt;System tools and libraries&lt;/li&gt;&#xA;&lt;li&gt;Settings&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The beauty of containers is that it doesn&amp;rsquo;t matter what it runs on; the container could be running on Windows, Linux, a laptop, RasPi, or anything that can install Docker. As it&amp;rsquo;s self sufficient, it&amp;rsquo;s completely agnostic to the underlying OS/compute. It&amp;rsquo;s another way to virtualise compute resources that isn&amp;rsquo;t as heavy-handed as having to install a whole new Virtual Machine.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-2e0f3&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-2e0f3&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;http://localhost:1313/containers.avif&#34; alt=&#34;Containers&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;One or many containers can run on a single host, virtualising the host&amp;rsquo;s resources and creating separate runtimes for each container.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;networking&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#networking&#34;&gt;Networking&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;Docker networking is most interesting to me for some reason, and there a few different options you can distribute and network containers.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bridge (default): An isolated network for containers on a single host&lt;/li&gt;&#xA;&lt;li&gt;host: Shares the host’s network stack&lt;/li&gt;&#xA;&lt;li&gt;overlay: Enables multi-host networking (used in Docker Swarm)&lt;/li&gt;&#xA;&lt;li&gt;macvlan: Assigns MAC addresses to containers for direct LAN access&lt;/li&gt;&#xA;&lt;li&gt;none: No networking&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Overlay is the type that Docker swarm uses, and is used to link containers hosted on different hosts, for a more distributed deployment.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;test-deployment&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/docker/#test-deployment&#34;&gt;Test Deployment&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;I followed a tutorial to spin up a NGINX reverse proxy which farms out requests to multiple flask servers. See diagram below.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-d447d&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-d447d&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;http://localhost:1313/Distributed_nginx.png&#34; alt=&#34;Distributed Docker Lab&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;I used a simple docker compose YAML file to spin up both the NGINX and Flask app.py containers, allowing me to create a distributed infrastructure with one command.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker-compose.yml &#xA;--&#xA;version: &#39;3&#39;&#xA;services:&#xA;web:&#xA;    build: ../flask_app&#xA;web2:&#xA;    build: ../flask_app&#xA;nginx:&#xA;    image: nginx:alpine&#xA;    ports:&#xA;    - 80:80&#xA;    volumes:&#xA;    - ./nginx.conf:/etc/nginx/nginx.conf&#xA;    depends_on:&#xA;    - web&#xA;    - web2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;The nginx container takes a prepopulated nginx config file to create the reverse proxy, distributing the HTTP requests across both Flask servers.&#xA;&lt;pre&gt;&lt;code&gt;# nginx.conf&#xA;events {}&#xA;http {&#xA;    upstream app_servers {&#xA;        server web:5000;&#xA;        server web2:5000;&#xA;    }&#xA;    server {&#xA;        listen 80;&#xA;        location / {&#xA;            proxy_pass http://app_servers;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;The Flask server hosts a simple Python that returns &#34;Hello Docker!&#34; and the hostname name of the container responding to the request:&#xA;&lt;pre&gt;&lt;code&gt;#!/usr/bin/python3&#xA;&#xA;# app.py&#xA;from flask import Flask&#xA;import socket&#xA;app = Flask(__name__)&#xA;@app.route(&#39;/&#39;)&#xA;def home():&#xA;    newstring = &amp;quot;Hello, Docker! Hostname is {0}\n&amp;quot;.format(socket.gethostname())&#xA;&#xA;    return newstring&#xA;if __name__ == &#39;__main__&#39;:&#xA;    app.run(host=&#39;0.0.0.0&#39;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;Sending multiple requests shows that Nginx is load balancing the requests across each Flask server:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is d9bcfe1b35d0&#xA;&#xA;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is 36f88db2fc2b&#xA;&#xA;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is d9bcfe1b35d0&#xA;&#xA;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is 36f88db2fc2b&#xA;&#xA;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is d9bcfe1b35d0&#xA;&#xA;root@mgmt-host:~/docker# curl localhost&#xA;Hello, Docker! Hostname is 36f88db2fc2b&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Next steps is to create a truly distributed setup; using multiple different hosts to create a converged deployment!&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Ansible</title>
      <link>http://localhost:1313/posts/ansible/</link>
      <pubDate>Mon, 07 Jul 2025 13:10:56 +0000</pubDate>
      <guid>http://localhost:1313/posts/ansible/</guid>
      <description>&lt;p&gt;Ansible is a great bit of software that can streamline and remove human error in deploying and managing a large network. It automates the management of remote systems and controls their desired state.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-3f269&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-3f269&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;https://docs.ansible.com/ansible/latest/_images/ansible_inv_start.svg&#34; alt=&#34;Overview of Ansible Components&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The Control node is where Ansible is installed. This is where the network inventory is created and stored.&lt;/li&gt;&#xA;&lt;li&gt;The Managed node(s) are the remote managed systems&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;I have deployed Ansible on a server that can reach my Arista nodes&amp;rsquo; mgmt network:&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-4e68f&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-4e68f&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;http://localhost:1313/Ansible_diagram.png&#34; alt=&#34;Arista Ansible Lab&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;Ansible obviously needs mgmt connectivity to the devices, it should fit in nicely along other network management resources which &lt;b&gt;of course are firewalled with 5-tuple rules, zoned approapriatly alongside same-trust-level resources, and only have strictly-controlled web-proxy-based outbound access to the Internet (if at all).&lt;/b&gt;&lt;/p&gt;&#xA;&lt;p&gt;My root Ansible directory contains a config file and 3 folders:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;drwxr-xr-x   5 root root  4096 Jul  3 11:05 .&#xA;drwxr-xr-x 101 root root  4096 Jul  7 13:44 ..&#xA;-rw-r--r--   1 root root 40643 Jul  3 09:25 ansible.cfg&#xA;drwxr-xr-x   3 root root  4096 Jul  7 13:44 inventory&#xA;drwxr-xr-x   2 root root  4096 Jul  3 11:21 playbooks&#xA;drwxr-xr-x   2 root root  4096 Jul  3 11:05 templates&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Inventory - this is where you define and organise your remote systems&lt;/li&gt;&#xA;&lt;li&gt;Playbooks - playbooks are files that contain instructions and tasks to acheive the device management and configuration&lt;/li&gt;&#xA;&lt;li&gt;Templates - if using JinJa2 in playbooks, this is where the device configuration templates are stored ready for access by the playbook&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2&gt;Inventory&lt;/h2&gt;&#xA;&lt;p&gt;The inventory can be organised in various different ways; I organise by device vendor and/or CLI language so I can easily apply playbooks to the whole vendor estate&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:/etc/ansible/inventory# ls&#xA;arista&#xA;&#xA;root@mgmt-host:/etc/ansible/inventory# cd arista/&#xA;root@mgmt-host:/etc/ansible/inventory/arista# ls&#xA;hosts.yaml  host_vars&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;Hosts.yaml is the inventory file where the devices are listed and organised into groups. &amp;ldquo;All&amp;rdquo; contains all the devices in this file, but you can use &amp;ldquo;children&amp;rdquo; to organise into arbitrary groups&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:/etc/ansible/inventory/arista# cat hosts.yaml&#xA;all:&#xA;hosts:&#xA;    leaf1:&#xA;    leaf2:&#xA;    spine1:&#xA;children:&#xA;    leafs:&#xA;    leaf1:&#xA;    leaf2:&#xA;    spines:&#xA;    spine1:&#xA;vars:&#xA;    ansible_connection: ansible.netcommon.network_cli&#xA;    ansible_network_os: arista.eos.eos&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&amp;ldquo;vars&amp;rdquo; contains variables common to the specific groups; here I&amp;rsquo;ve listed vars under &amp;ldquo;all&amp;rdquo; to apply to all the hosts in the inventory file.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:/etc/ansible/inventory/arista# cd host_vars/&#xA;root@mgmt-host:/etc/ansible/inventory/arista/host_vars# ls&#xA;leaf1.yaml  leaf2.yaml  spine1.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;&amp;ldquo;host-vars&amp;rdquo; contains files that allow arbitrary per-device variables; here I&amp;rsquo;ve defined hostname and vtep_ip. These can be accessed in the Jinja2 templating module&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:/etc/ansible/inventory/arista/host_vars# cat leaf1.yaml&#xA;hostname: leaf1&#xA;vtep_ip: 10.0.0.1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;h2&gt;Playbooks&lt;/h2&gt;&#xA;&lt;p&gt;Playbooks are lists of tasks and actions to perform on the remote devices. They are YAML files, and can have 1 or many tasks.&lt;/p&gt;&#xA;&lt;p&gt;Ansible content collections can add content not included in the Ansible &amp;ldquo;core&amp;rdquo;. They are a way to add vendor or other content without building it directly into Ansible.&lt;/p&gt;&#xA;&lt;p&gt;The Arista EOS collection is called &amp;ldquo;arista.eos&amp;rdquo; - there are many modules in the collection, including an arbitrary CLI and HTTP API module.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/collections/arista/eos/index.html&#34;&gt;Ansible Arista EOS Collection&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;See an example of a Playbook below, updating all the management interface descriptions:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;---&#xA;&#xA;- name: Configure interface descriptions&#xA;hosts: all&#xA;gather_facts: false&#xA;&#xA;tasks:&#xA;&#xA;    - name: Add interface desc&#xA;    arista.eos.eos_interfaces:&#xA;        config:&#xA;        - name: Management1&#xA;            description: &amp;quot;configured by Ansible&amp;quot;&#xA;        state: merged&#xA;    become: true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;When the playbook is run against the &amp;ldquo;arista&amp;rdquo; inventory, you get an output based of the Playbook&amp;rsquo;s success&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;root@mgmt-host:/etc/ansible# ansible-playbook playbooks/pb_interface_desc.yaml -i inventory/arista  -uadmin&#xA;&#xA;PLAY [Configure interface descriptions] ***********************************************************************************************************&#xA;&#xA;TASK [Add interface desc] *************************************************************************************************************************&#xA;changed: [leaf1]&#xA;changed: [spine1]&#xA;changed: [leaf2]&#xA;&#xA;PLAY RECAP ****************************************************************************************************************************************&#xA;leaf1                      : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0&#xA;leaf2                      : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0&#xA;spine1                     : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0&#xA;&#xA;root@mgmt-host:/etc/ansible#&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2&gt;Summary&lt;/h2&gt;&#xA;&lt;p&gt;There&amp;rsquo;s lots to unpack, but this is what&amp;rsquo;s meant as &amp;ldquo;infrastructure as code&amp;rdquo;; an entire network can be managed and maintained purely by building inventories and playbooks. Once you&amp;rsquo;ve got to grips with host_vars, the size of the network almost becomes irrelevant.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Current Skills</title>
      <link>http://localhost:1313/posts/current-skills/</link>
      <pubDate>Tue, 17 Jun 2025 10:25:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/current-skills/</guid>
      <description>&lt;p&gt;In my last post I posted the DevOps knowledge journey, allowing engineers to learn all the skills necessary. Here I want to do a gap analysis; what skills do I have compared to the Roadmap, and where do I need to direct my learning.&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;learn-git&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/current-skills/#learn-git&#34;&gt;Learn Git&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;I have beginner to intermediate skills and knowledge of Git.&lt;/p&gt;&#xA;&lt;p&gt;I have a public GitHub with various repos of personal and professional projects:&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.github.com/tbendall&#34;&gt;Tristan&amp;rsquo;s GitHub Profile&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;This is a great guide to introduce into git.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://rogerdudler.github.io/git-guide&#34;&gt;Git Introduction Guide&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;learn-programming-languages&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/current-skills/#learn-programming-languages&#34;&gt;Learn Programming Languages&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;I have been using and learning Python for over 10 years in my capacity as Network Engineer/Design/Architect. I have completed various projects using Python that have led to a high success rate of the project&lt;/p&gt;&#xA;&lt;p&gt;Using Python to interact with Juniper routers and switches proves especially powerful to manage a large estate&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;from jnpr.junos import Device &#xA;   with Device(host=host_ip,user=username,passwd=password,port=22) as dev:&#xA;   test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>DevOps Roadmap</title>
      <link>http://localhost:1313/posts/devops-roadmap/</link>
      <pubDate>Tue, 17 Jun 2025 08:10:12 +0000</pubDate>
      <guid>http://localhost:1313/posts/devops-roadmap/</guid>
      <description>&lt;p&gt;A friend recommended to me the DevOps roadmap - a learning journey to develop the various DevOps and Infrastructure skills that are in most demand.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/milanm/DevOps-Roadmap&#34;&gt;https://github.com/milanm/DevOps-Roadmap&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-63753&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-63753&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;https://github.com/milanm/DevOps-Roadmap/blob/master/DevOps%20Roadmap.png?raw=true&#34; alt=&#34;DevOps Journey&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>My First Post</title>
      <link>http://localhost:1313/posts/my-first-post/</link>
      <pubDate>Tue, 03 Jun 2025 13:41:12 +0000</pubDate>
      <guid>http://localhost:1313/posts/my-first-post/</guid>
      <description>&#xA;&#xA;&#xA;&#xA;&lt;h1 id=&#34;overview&#34;&gt;&#xA;  &lt;a class=&#34;Heading-link u-clickable&#34; href=&#34;http://localhost:1313/posts/my-first-post/#overview&#34;&gt;Overview&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p&gt;I wanted to set up a site that demonstrated my foray into DevOps skills, so as a project in and of itself, I&amp;rsquo;ve created this platform as a challenge and demonstration of my infrastructure skills.&lt;/p&gt;&#xA;&lt;p&gt;&#xA;    &#xA;&#x9;    &lt;input type=&#34;checkbox&#34; id=&#34;zoomCheck-8b7f7&#34; hidden&gt;&#xA;&#x9;        &lt;label for=&#34;zoomCheck-8b7f7&#34;&gt;&#xA;&#x9;&#x9;&#x9;        &lt;img class=&#34;zoomCheck&#34; loading=&#34;lazy&#34; decoding=&#34;async&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  src=&#34;http://localhost:1313/diagram.png&#34; alt=&#34;Diagram of initial DevOps setup&#34; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;                  /&gt;&#xA;&#x9;&#x9;&#x9;&#x9;    &lt;/label&gt;&#xA;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Hosted on a Free SKU Azure VM&lt;/li&gt;&#xA;&lt;li&gt;Uses GitHub for basic Version Controlling&lt;/li&gt;&#xA;&lt;li&gt;Uses my bendall.co domain to create a Dynamic DNS entry for &amp;ldquo;devops.bendall.co&amp;rdquo; using ddclient package&lt;/li&gt;&#xA;&lt;li&gt;VM is protected with a NSG to lockdown access for mgmt and web&lt;/li&gt;&#xA;&lt;li&gt;VM is secured with non-standard SSH port and public/private keys enabling secure and passwordless login&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;li&gt;NGINX is used as a reverse proxy for Hugo easy site builder (as I&amp;rsquo;m terrible at front-end)&lt;/li&gt;&#xA;&lt;li&gt;Let&amp;rsquo;s Encrypt TLS Certificate used instead of self-signed&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;li&gt;VSCode with Remote-SSH used for remote development; let&amp;rsquo;s face it, no-one should be coding in a terminal these days&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
  </channel>
</rss>
